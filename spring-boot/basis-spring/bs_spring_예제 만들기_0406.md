## 프로젝트 생성
- spring.start.io에서 프로젝트 생성
- 라이브러리를 받아옴
- Build시 Gradle로 변경

## 비즈니스 요구사항과 설계
- Pass
 
## 회원 도메인 설계
- 외부 시스템과 연동할 수 있다. (미확정) 
- 클라이언트 -> 회원서비스 -> 메모리 회원 저장소
- 클래스 다이어그램 : 서버 실행하지 않고 클래스만 보여줌
- 객체 다이어그램 : 서버 떠서 클라이언트 실제 사용하는것 (실제 new한 인스턴스끼리 참조이다.)

## 주문과 할인 도메인 설계 
- 역할들의 협력 관계를 그대로 재사용할 수 있다.

## 설계 측면
- 클라이언트 코드인 OrderServiceImpl 은 DiscountPolicy 의 인터페이스 뿐만 아니라 구체 클래스도 함께 의존한다. 
- 추상 에만 의존하도록 해야한다. (=인터페이스만 의존하도록 해야한다.)
- DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경하면 된다.

### 해결방안
- 이 문제를 해결하려면 누군가가 클라이언트인 OrderServiceImpl 에 DiscountPolicy 의 구현 객체를 대신 생성하고 주입해주어야 한다.

## 관심사 분리
- AppConfig는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.
- 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스를 만들자.
- final이 붙어있으면 기본으로 할당되거나 생성자를 통해서 할당되어야 한다. 
- MemberServiceImpl 은 이제부터 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중하면 된다.
- 객체의 생성과 연결은 AppConfig 가 담당한다.
- 클라이언트인 memberServiceImpl 입장에서 보면 의존관계를 마치 외부에서 주입해주는 것 같다고 해서 DI(Dependency Injection) 우리말로 의존관계 주입 또는 의존성 주입이라 한다.
- AppConfig는 구체 클래스를 선택한다. 배역에 맞는 담당 배우를 선택한다. 애플리케이션이 어떻게 동작해야 할지 전체 구성을 책임진다.

## 새로운 구조와 할인 정책 적용
- AppConfig의 등장으로 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성(Configuration)하는 영역으로 분리되었다.
- 구성영역의 코드만 손대면 되고, 사용영역의 코드는 건들지 않아도 된다. 
- Ctrl+R이 이전 실행을 하도록 한다. 
- 이제 할인 정책을 변경해도, 애플리케이션의 구성 역할을 담당하는 AppConfig만 변경하면 된다. 클라이언트 코드인 OrderServiceImpl 를 포함해서 사용 영역의 어떤 코드도 변경할 필요가 없다.
- 사용영역에 있는것은 전혀 손댈 필요가 없다. 

## 전체 흐름 정리
- 새로 개발한 정률 할인 정책을 적용하려고 하니 클라이언트 코드인 주문 서비스 구현체도 함께 변경해야함
- 주문 서비스 클라이언트가 인터페이스인 DiscountPolicy 뿐만 아니라, 구체 클래스인 FixDiscountPolicy 도 함께 의존 DIP 위반
- 공연 기획자인 AppConfig가 등장
- AppConfig는 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고, 연결하는 책임
- 역할과 구현을 분리해야 한다. 

## 좋은 객체 지향 설계의 5가지 원칙의 적용
- 한 클래스는 하나의 책임만 가져야 한다. (SRP)
- DIP 의존관계 역전 원칙
    - 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- OCP
    - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

